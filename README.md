# OpenMind

## 팀원
이지수 : button, listpage, 데이터 구현
변지인 : reation, dropdown, toast, answerpage 구현
손승현 : feedcard, postpage 구현
한태욱 : input, usercard, pagenation, badge, mainpage, modalpage 구현

## 상세설명
### 이지수
#### 담당
- 멋쟁이 팀장😎
- notion 제작 및 관리 (컨벤션 정리, 일정관리, 자료 모음)
- 초기 api 데이터 세팅
- 포켓몬 api 데이터 세팅
- Btn 컴포넌트 구현
    - btn 컴포넌트가 html btn 태그와 동일한 속성을 가지도록 구현 (…rest 속성 이용)
    - 화살표 아이콘의 유무를 arrow prop과 &&연산자를 사용해서 구현
- List page 구현
    - pagenation 구현 (offset 사용)
#### 트러블슈팅
- button 컴포넌트 처음 제작 시 figma 상의 공용 컴포넌트 부분을 보고 구현
- 이후 각자 페이지 제작하면서 button 사이즈가 안맞기 시작함
- 처음에는 단순히 size가 2-3개 정도라고 생각하고 prop으로 넘겨주려 함
- 찾아보니 사이즈 종류가 9 ~ 10개 였음 → prop 절대 불가
- button 컴포넌트를 html 상의 button 태그와 동일한 방식으로 사용하는 방법을 고민
- 특정적인 theme, disabled, arrow, children을 제외한 button의 모든 속성을 사용할 수 있도록 …rest 를 사용해줌 → onClick 등의 속성 사용 용이  
- 다양한 사이즈 부분은 width와 height 값을 제거하고 padding 값으로 버튼 사이즈가 자동으로 움직이도록 조절 (align-items 속성 안 적어주면 기본 값이 stretch)
- padding 값은 종류가 2가지였고, 주의할 점은 한 페이지에서 같은 버튼 두개의 패딩값이 다른 점이었는데,
- css 상에서 반응형으로 해당 너비일 때, 특정 theme의 클래스 명이 동시에 존재하는 경우에 다른 padding 값을 주어 해결함

### 변지인

#### 담당
- 깃허브초기세팅
    - 브랜치
    - 이슈템플릿
    - pr템플릿
- 공유 레포세팅
- 초기api불러오
    - reactionApi(axios쓰기 전 버전)
- reaction컴포넌트 구현
    - api이용하여 type에 따른 like, dislike 불러오고 판별하는 로직 구현
    - 반별 이후 색상변경
    - 반별 이후 아이콘 변경
    - 버튼 클릭 시 한번만 실행되도록 로직 구현
    - api이용하여 클릭 시 색상 바뀌는거 svg의 fill 통해서 구현
    - api이용하여 클릭 시에만 숫자가 보이도록 구현
    - 커서 포인터
- dropdown컴포넌트 구현
    - 클릭 시 색상 바뀌는거 svg의 fill 통해서 구현
    - 클릭 시(+호버) 드롭다운 리스트가 나오게 구현
    - 드롭다운리스트 목록을 클릭 시 드롭다운 박스에 표시되는 값이 달라지도록 구현
    - api이용하여 ‘이름순’ 클릭 시 데이터가 이름순서대로 정렬
    - api이용하여 ‘최신순’ 클릭 시 데이터가 시간순서대로 정렬
    - 받아올 데이터 기초 구현
    - 커서 포인터
- toast컴포넌트 구현
- Answer페이지 구현
    - 사용자 api받아오는 기능 구현
    - AnswerFeedCard전체 삭제하는 ‘삭제하기버튼’구현
        - map()을 통해 모든 FeedCard를 다룰 수 있도록 구현
        - 비동기적으로 실행되어 모두 삭제가 되지않고 결과를 출력하는 문제를promise.all을 통해 해결
        - setState를 인자로 받아와서 페이지 렌더링 구현
    - AnswerFeedCard 구현
        - bage를 통해 답변이 없으면 미답변, 있으면 답변완료 조건부 랜더링
        - useState를 통해 새로고침 로직 구현(답변작성, 수정, 삭제 등 변화가 발생하면 다 자동으로 랜더링)
        - 답변이 있을 때만 Kebab버튼을 사용할 수 있도록 구현
        - 답변 없을 시 input 활성화
        - input에 내용 있으면 버튼 활성화
    - AnswerFeedCard 내부 Kebab버튼
        - useState를 통해 클릭시 Kebab자체가 열리고, 다시 누르면 닫히게 구현
        - 수정하기 Kebab 누를시 답변했던 api를 받아와서 작업하도록 구현
        - 수정완료 버튼 누를시
        - input에 내용 있으면 버튼 활성화
        - 커서 포인터
          
#### 트러블슈팅
- 한줄평 : 얽혀있는 기능들을 정리하고, 데이터를 분석해서 사용하는게 어려웠지만 어떻게 구현할까 다채롭게 사고해 볼 수 있는 시간이였습니다.
    - 가장 처음 기능은 답변이 있을때만 케밥이 열려야했다
    - 처음엔 if-esle문을 통해 구현하려했으나, return문안에서 쓰기엔 무리였고, 밖에서 함수로 빼서 쓸경우 그 안에 컴포넌트가 들어가야하기에 불가능 했다
    - 그래서 답변이 있을경우를 삼항연산자를 통해 분리했다
    - 이제 답변이 있을경우 케밥버튼은 열리지만 한번만 실행되기에 한번 클릭 시 열리고, 다시 클릭시 닫힐 수 있도록 useState에 !를 활용하여 로직을 만들었다.
    - 또한 케밥의 목록, 즉 리스트자체도 클릭시에만 보이고 다시 닫혀야하므로 비슷한 방식으로 구현했다.
    - 이제 케밥의 리스트를 보면, 수정하기와 삭제하기를 기능할 줄 알아야하는데, 여기서부터 문제가 시작한다.
    - 기능 자체는 케밥 컴포넌트안에서 구현하는데, 랜더링되는 부분은 상위 폴더였기에 1. 컴포넌트로 받아오는 방식 ⇒ 컴포넌트안에 함수를 받아올 수 없어서 편집하지 못함 2.상위폴더안에 다 작성 ⇒ 가독성도 떨어지고, 이미 전체삭제 기능이 있어서 그 기능과 혼동, 3.props로 받아와서 작성 ⇒ 이방식을 채택해서 set자체를 받아와서 사용했다
    - setState는 여러 요소를 구분해서 쓰기위해 객체로 선언했고, 삭제하기는 kebab.jsx안에 수정하기는 answercardrender.jsx안에 넣어서 구현했다.
    - updateFeed는 새로고침 로직인데, 처음엔 window.location.reload()로 구현하려 했으나, 불필요한 랜더링을 하여 아래와 같이 만들어서 사용했습니다.(results는 상위페이지에서 받아온 useState)

### 손승현

#### 담당
- 매일매일 회의록 작성 
→ 팀원들이 매일매일 논의한 내용들을 잊지않고 리마인드할 수 있게 함
- API 흐름 정리
- FeedCard 공용 컴포넌트 구현
    - API 연동 전, 임시 데이터를 만들어서 컴포넌트 안에 들어갈 데이터 자리를 미리 만들어주고 props를 미리 넘겨줌 (후에 연동 작업이 편하게끔)
  - 답변 여부에 따라 답변완료/미답변 뱃지 조건부 렌더링
  - FeedCard 컴포넌트 안에 들어가는 질문인 FeedQuestion 컴포넌트 구현
  - FeedCard 컴포넌트 안에 들어가는 답변을, 응답 데이터 내용에 따라 다르게 렌더링 (조건부 렌더링)
(ex. 거절하면 RejectAnswer 컴포넌트 렌더링, 거절하지 않고 답변 데이터가 없으면 EmptyAnswer 컴포넌트 렌더링, 거절하지 않고 답변 데이터가 있으면 SentAnswer 컴포넌트 렌더링)
  - subjectId를 useParams로 받아와서 ID마다 다른 유저 데이터를 동적인 경로를 통해 피드카드 안에서 렌더링
- children props를 이용하여서, 레이아웃을 사용할때, 레이아웃 안에 다른 내용들이 들어갈 수 있게 유연성과 재사용성을 고려하여 레이아웃 구현
- PostPage 질문 피드 페이지 구현
  - axios로 API 연동해서 질문 데이터 불러오기 
(useCallback으로 메모이제이션 최적화)
  - 레이아웃과 피드카드의 props로 질문 데이터 뿌려주기
  - map 함수로 피드카드들 렌더링
  - axios로 API 연동해서 유저 데이터 불러오기
  - 시간 데이터 가공해서 화면에 보이게 하기
  - ‘아직 질문이 없습니다’ 컴포넌트 만들기
  -  ‘질문 작성하기’ 플로팅 버튼 위치시키기
  - 질문 작성 버튼이 화면 너비에 따라 반응형으로 글자가 바뀜(화면 너비가 768px 이상이면 '질문 작성하기', 그 이하는 '질문 작성')
    - resize이벤트와 useState와 useEffect 사용
  - 데이터 불러올 때 로딩 중 상태 로직 추가
  - 질문 데이터 최신순으로 무한 스크롤 기능
    - 스크롤 이벤트 → Intersection Observer API로 구현
    (페이지 하단의 lastElementRef가 viewport에 진입하는 순간을 감지하여 추가 데이터 로드)
    - 구현 방법 변경 이유 : 브라우저마다 스크롤 위치가 상이할 수 있고, 이벤트가 계속 발생해서 성능 이슈가 발생할 수 있음. 하지만 Intersection Observer API는 브라우저에 내장된 API이고, 성능이 더 좋음
  - 모달을 연결함. “질문 작성하기” 버튼을 클릭하면 “질문을 작성하세요” 모달이 뜸
  - 모달에서 질문 post 후 자동 새로고침 -> 페이지에서 최신 질문 데이터를 바로 렌더링될 수 있게 함 
  - “링크 아이콘”을 클릭하면 URL을 클립보드에 복사하고, “URL이 복사되었습니다” 토스트 메세지가 5초 동안 보이다가 사라짐
    - 클립보드 복사와 토스트 메세지 구현 시 모두 라이브러리 안 씀!!!!
    - 동기적인 순서로 구현
    - 토스트 메세지가 보이다가 사라지는 애니메이션도 추가
  - “카카오 아이콘”을 클릭하면 실제 카카오톡으로 공유 가능 
(카카오톡 공유 API 문서 학습 후 사용)
  - “페이스북 아이콘”을 클릭하면 페이스북으로 공유 가능
  - Listpage의 UserCard에서 PostPage로 넘어갈 때, UserCard 컴포넌트의 props로 /post/subjectId로 넘어갈 수 있는 함수를 내려줌으로써
postpage에서는 그 subjectId를 useParams로 받아와서 ID마다 다른 질문 데이터를 동적인 경로를 통해 렌더링
- index.html 수정
  - favicon 추가
  - 글씨체 추가
  - 페이스북 공유 시 미리보기 내용들 추가
- PPT 제작
